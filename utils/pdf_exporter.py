# utils/pdf_exporter.py - Updated with better error handling
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from io import BytesIO
from collections import defaultdict
from typing import List, Dict, Any, Union

def export_to_pdf(questions: List[Union[Dict[str, str], Any]]) -> bytes:
    """
    Export interview questions to PDF format with robust error handling.
    
    Args:
        questions: List of question dictionaries or any format from CrewAI
        
    Returns:
        PDF data as bytes
    """
    buffer = BytesIO()
    
    try:
        # Create canvas with letter size
        c = canvas.Canvas(buffer, pagesize=letter)
        width, height = letter
        
        # Set up fonts and styling
        c.setFont("Helvetica-Bold", 16)
        c.drawString(50, height - 50, "Technical Interview Questions")
        
        c.setFont("Helvetica", 10)
        c.drawString(50, height - 70, "Generated by AI Interview Question Generator")
        
        # Process and group questions
        grouped_questions = process_questions_for_pdf(questions)
        
        # Start content positioning
        y_position = height - 120
        
        # Draw questions by category
        for category, question_list in grouped_questions.items():
            # Check if we need a new page
            if y_position < 100:
                c.showPage()
                y_position = height - 50
            
            # Draw category header
            c.setFont("Helvetica-Bold", 14)
            c.drawString(50, y_position, f"{category.upper()}")
            y_position -= 25
            
            # Draw questions in this category
            c.setFont("Helvetica", 11)
            for i, question in enumerate(question_list, 1):
                # Check if we need a new page
                if y_position < 80:
                    c.showPage()
                    y_position = height - 50
                    c.setFont("Helvetica", 11)
                
                # Draw question number and text
                question_text = f"Q{i}. {question}"
                
                # Handle long questions by wrapping text
                wrapped_lines = wrap_text(question_text, width - 100)
                
                for line in wrapped_lines:
                    c.drawString(70, y_position, line)
                    y_position -= 18
                
                y_position -= 5  # Extra space between questions
            
            y_position -= 15  # Extra space between categories
        
        # Add footer
        c.setFont("Helvetica", 8)
        c.drawString(50, 30, f"Generated on {get_current_date()}")
        
        c.save()
        buffer.seek(0)
        return buffer.getvalue()
        
    except Exception as e:
        # Create error PDF if generation fails
        return create_error_pdf(str(e))

def process_questions_for_pdf(questions: List[Any]) -> Dict[str, List[str]]:
    """
    Process questions into a format suitable for PDF generation.
    Handles various input formats robustly.
    """
    grouped = defaultdict(list)
    
    if not questions:
        grouped["General"] = ["No questions were generated. Please try again."]
        return dict(grouped)
    
    for q in questions:
        try:
            if isinstance(q, dict):
                # Standard dictionary format
                question_text = str(q.get("question", q.get("text", str(q))))
                category = str(q.get("category", "General"))
            elif isinstance(q, str):
                # String format
                question_text = q
                category = "General"
            else:
                # Unknown format - convert to string
                question_text = str(q)
                category = "General"
            
            # Clean up the question text
            question_text = question_text.strip()
            if not question_text:
                continue
                
            # Add to appropriate category
            if category not in grouped:
                grouped[category] = []
            grouped[category].append(question_text)
            
        except Exception as e:
            # If individual question processing fails, add error message
            grouped["General"].append(f"Error processing question: {str(e)}")
    
    # Ensure we have at least some content
    if not any(grouped.values()):
        grouped["General"] = ["Failed to process questions. Please check the input format."]
    
    return dict(grouped)

def wrap_text(text: str, max_width: int, font_size: int = 11) -> List[str]:
    """
    Wrap text to fit within the specified width.
    Simple implementation for PDF text wrapping.
    """
    # Approximate character width (this is rough but works for most cases)
    chars_per_line = max_width // (font_size * 0.6)
    
    words = text.split()
    lines = []
    current_line = ""
    
    for word in words:
        if len(current_line + " " + word) <= chars_per_line:
            if current_line:
                current_line += " " + word
            else:
                current_line = word
        else:
            if current_line:
                lines.append(current_line)
            current_line = word
    
    if current_line:
        lines.append(current_line)
    
    return lines if lines else [text]

def get_current_date() -> str:
    """Get current date as formatted string."""
    from datetime import datetime
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def create_error_pdf(error_message: str) -> bytes:
    """
    Create a simple error PDF when main PDF generation fails.
    """
    buffer = BytesIO()
    
    try:
        c = canvas.Canvas(buffer, pagesize=letter)
        width, height = letter
        
        c.setFont("Helvetica-Bold", 16)
        c.drawString(50, height - 50, "PDF Generation Error")
        
        c.setFont("Helvetica", 12)
        c.drawString(50, height - 100, "An error occurred while generating the PDF:")
        
        c.setFont("Helvetica", 10)
        error_lines = wrap_text(error_message, width - 100)
        y_pos = height - 130
        
        for line in error_lines:
            c.drawString(50, y_pos, line)
            y_pos -= 15
        
        c.drawString(50, y_pos - 30, "Please try generating the questions again.")
        
        c.save()
        buffer.seek(0)
        return buffer.getvalue()
        
    except Exception:
        # If even error PDF fails, return minimal PDF
        buffer = BytesIO()
        c = canvas.Canvas(buffer, pagesize=letter)
        c.drawString(50, 750, "Error: Could not generate PDF")
        c.save()
        buffer.seek(0)
        return buffer.getvalue()